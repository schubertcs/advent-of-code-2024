package aoc.day07;

import aoc.common.Pair;

import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Task2 {

    public static void main(String[] args) {
        try {
            new Task2().run();
        } catch (final URISyntaxException | IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void run() throws URISyntaxException, IOException {
        final Path path = Paths.get(getClass().getClassLoader()
                .getResource("day07/input1").toURI());

        try (final Stream<String> lines = Files.lines(path)) {
            final List<OperationlessEquation> equations = lines.map(OperationlessEquation::build).toList();
            long resultSum = 0;
            for (final OperationlessEquation equation : equations) {
                if(bruteForce(equation)) {
                    resultSum += equation.result;
                }
            }
            System.out.println(resultSum);
        }
    }

    private boolean bruteForce(final OperationlessEquation equation) {
        return EnumPermutations.generatePermutations(Operation.class, equation.getNumberOfOperatorsRequired()).map(p -> new Pair<>(equation, equation.isFulfilled(p))).anyMatch(r -> r.y == EquationResult.FULFILLED);
    }

    static class OperationlessEquation {
        private final List<Integer> operands;
        private final long result;

        OperationlessEquation(final List<Integer> operands, final long result) {
            this.operands = operands;
            this.result = result;
        }

        static OperationlessEquation build(final String line) {
            final String[] split = line.split(":");
            final long result = Long.parseLong(split[0]);
            final List<Integer> operands = Arrays.stream(split[1].trim().split(" ")).map(Integer::parseInt).collect(Collectors.toList());
            return new OperationlessEquation(operands, result);
        }

        public int getNumberOfOperatorsRequired() {
            return operands.size() - 1;
        }

        public EquationResult isFulfilled(final List<Operation> operations) {
            if(getNumberOfOperatorsRequired() < operations.size()) {
                throw new RuntimeException("Too many operations!");
            }
            long currentValue = operands.get(0);

            for (int i = 0; i < operations.size(); i++) {
                final Operation operation = operations.get(i);
                final long secondOperand = operands.get(i + 1);
                currentValue = operation.apply(currentValue, secondOperand);
            }

            if(currentValue > result) {
                return EquationResult.NOT_FULFILLED;
            }

            if(currentValue == result && getNumberOfOperatorsRequired() == operations.size()) {
                return EquationResult.FULFILLED;
            }

            if(currentValue == result && getNumberOfOperatorsRequired() > operations.size()) {
                return EquationResult.NOT_FULFILLED;
            }

            if(currentValue < result && getNumberOfOperatorsRequired() == operations.size()) {
                return EquationResult.NOT_FULFILLED;
            }

            if(currentValue < result && getNumberOfOperatorsRequired() > operations.size()) {
                return EquationResult.NOT_ENOUGH_OPERATIONS;
            }

            throw new RuntimeException("Should not happen");
        }

        @Override
        public String toString() {
            return "OperationlessEquation{" +
                    "operands=" + operands +
                    ", result=" + result +
                    '}';
        }
    }

    enum EquationResult {
        FULFILLED,
        NOT_FULFILLED,
        NOT_ENOUGH_OPERATIONS;
    }

    enum Operation {
        ADDITION {
            @Override
            long apply(final long a, final long b) {
                return a+b;
            }
        },
        MULTIPLICATION {
            @Override
            long apply(final long a, final long b) {
                return a*b;
            }
        },
        CONCATENATION {
            @Override
            long apply(final long a, final long b) {
                return Long.parseLong(Long.toString(a) + b);
            }
        };

        abstract long apply(long a, long b);
    }

    public class EnumPermutations {
        /* Generated by ChatGPT */
        public static <E extends Enum<E>> Stream<List<E>> generatePermutations(Class<E> enumType, int length) {
            if (length <= 0) {
                return Stream.empty(); // No permutations for non-positive length
            }

            // Get all enum constants
            E[] elements = enumType.getEnumConstants();

            // Use an iterative approach to generate permutations
            List<List<E>> result = new ArrayList<>();
            generatePermutationsIterative(elements, length, result);
            return result.stream();
        }

        private static <E> void generatePermutationsIterative(E[] elements, int length, List<List<E>> result) {
            // List to hold the current permutation
            List<E> current = new ArrayList<>();
            generatePermutationsRecursive(elements, length, current, result);
        }

        private static <E> void generatePermutationsRecursive(E[] elements, int length, List<E> current, List<List<E>> result) {
            if (current.size() == length) {
                // Add the current permutation to the result
                result.add(new ArrayList<>(current));
                return;
            }

            // Iterate over all elements and build permutations
            for (E element : elements) {
                current.add(element);
                generatePermutationsRecursive(elements, length, current, result);
                current.remove(current.size() - 1); // Backtrack
            }
        }
    }
}
